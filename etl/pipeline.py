"""High level orchestration for the Guaxindiba ETL pipeline."""

from __future__ import annotations

import argparse
from dataclasses import dataclass, field
from os import PathLike
from pathlib import Path
from typing import Any, Callable, Mapping, Sequence

import numpy as np
import pandas as pd
from shapely.geometry import Point
from shapely.geometry.base import BaseGeometry

from .load.csv import save_dataframe as default_save_dataframe
from .load.csv import save_geometry as default_save_geometry

FireFetcher = Callable[..., pd.DataFrame]
GeometryFetcher = Callable[..., BaseGeometry]
Transformer = Callable[..., pd.DataFrame]
DataFrameLoader = Callable[[pd.DataFrame, Path | str | PathLike[str]], Any]
GeometryLoader = Callable[[BaseGeometry, Path | str | PathLike[str]], Any]


def _ensure_path(path: Path | str | PathLike[str]) -> Path:
    if isinstance(path, Path):
        return path
    if isinstance(path, (str, PathLike)):
        return Path(path)
    raise TypeError("path must be a string, Path or os.PathLike instance")


@dataclass(slots=True)
class PipelineConfig:
    """Configuration container used by :func:`run_pipeline`."""

    dataframe_output: Path | str | PathLike[str]
    geometry_output: Path | str | PathLike[str] | None = None
    apply_transform: bool = True
    fetch_fire_data: FireFetcher | None = None
    fetch_fire_kwargs: dict[str, Any] = field(default_factory=dict)
    get_reserve_geometry: GeometryFetcher | None = None
    reserve_kwargs: dict[str, Any] = field(default_factory=dict)
    transformer: Transformer | None = None
    transformer_kwargs: dict[str, Any] = field(default_factory=dict)
    dataframe_loader: DataFrameLoader = default_save_dataframe
    geometry_loader: GeometryLoader = default_save_geometry

    def __post_init__(self) -> None:
        self.dataframe_output = _ensure_path(self.dataframe_output)
        if self.geometry_output is not None:
            self.geometry_output = _ensure_path(self.geometry_output)

        if self.fetch_fire_data is None:
            from .extract.terrabrasilis import fetch_fire_data, TerraBrasilisConfig, TerraBrasilisFilters

            self.fetch_fire_data = fetch_fire_data
            self.fetch_fire_kwargs.setdefault("filters", TerraBrasilisFilters())
            self.fetch_fire_kwargs.setdefault(
                "config",
                TerraBrasilisConfig(headless=True, pause_after_apply=False, close_browser_on_finish=True),
            )

        if self.get_reserve_geometry is None:
            from .extract.reserve import get_reserve_geometry

            self.get_reserve_geometry = get_reserve_geometry

        if self.transformer is None:
            from .transform.spatial import mark_points_inside

            self.transformer = mark_points_inside


@dataclass(slots=True)
class PipelineResult:
    """Container holding the products generated by :func:`run_pipeline`."""

    fires: pd.DataFrame
    geometry: BaseGeometry
    result: pd.DataFrame


def _coerce_config(config: PipelineConfig | Mapping[str, Any]) -> PipelineConfig:
    if isinstance(config, PipelineConfig):
        return config
    if isinstance(config, Mapping):
        return PipelineConfig(**dict(config))
    raise TypeError("config must be a PipelineConfig instance or a mapping")


def run_pipeline(config: PipelineConfig | Mapping[str, Any]) -> PipelineResult:
    """Execute extraction, transformation and loading steps."""

    cfg = _coerce_config(config)

    if cfg.fetch_fire_data is None or cfg.get_reserve_geometry is None:
        raise ValueError("fetch_fire_data and get_reserve_geometry callables must be provided")

    fires = cfg.fetch_fire_data(**cfg.fetch_fire_kwargs)
    fires = _ensure_geometry_column(fires)
    geometry = cfg.get_reserve_geometry(**cfg.reserve_kwargs)

    if cfg.apply_transform and cfg.transformer is not None:
        result_df = cfg.transformer(fires, geometry, **cfg.transformer_kwargs)
    else:
        result_df = fires.copy()

    cfg.dataframe_loader(result_df, cfg.dataframe_output)

    if cfg.geometry_output is not None:
        cfg.geometry_loader(geometry, cfg.geometry_output)

    return PipelineResult(fires=fires, geometry=geometry, result=result_df)


def _ensure_geometry_column(df: pd.DataFrame) -> pd.DataFrame:
    if "geometry" in df.columns:
        return df

    lower_columns = {name.lower(): name for name in df.columns}
    lat_col = next((lower_columns[key] for key in ("lat", "latitude") if key in lower_columns), None)
    lon_col = next((lower_columns[key] for key in ("lon", "longitude", "long") if key in lower_columns), None)

    if lat_col is None or lon_col is None:
        return df

    lat_series = pd.to_numeric(df[lat_col], errors="coerce")
    lon_series = pd.to_numeric(df[lon_col], errors="coerce")

    geometries: list[Point] = []
    valid_index: list[int] = []

    for idx, (lon, lat) in zip(df.index, zip(lon_series, lat_series)):
        try:
            lon_f = float(lon)
            lat_f = float(lat)
        except (TypeError, ValueError):
            continue

        if not np.isfinite(lon_f) or not np.isfinite(lat_f):
            continue

        valid_index.append(idx)
        geometries.append(Point(lon_f, lat_f))

    if not geometries:
        return df

    result = df.copy()
    result.loc[valid_index, "geometry"] = geometries
    return result


def build_parser() -> argparse.ArgumentParser:
    """Return the CLI argument parser used by :func:`main`."""

    parser = argparse.ArgumentParser(description="Executa o pipeline ETL completo.")
    parser.add_argument(
        "--fires-output",
        type=Path,
        default=Path("data/focos_processados.csv"),
        help="Arquivo CSV onde os focos transformados serão salvos.",
    )
    parser.add_argument(
        "--geometry-output",
        type=Path,
        default=Path("data/reserva.geojson"),
        help="Arquivo GeoJSON para salvar a geometria da reserva.",
    )
    parser.add_argument(
        "--reserve-cache",
        type=Path,
        default=None,
        help="Arquivo GeoJSON opcional utilizado como cache da geometria.",
    )
    parser.add_argument(
        "--reserve-name",
        default="Estação Ecológica Estadual de Guaxindiba",
        help="Nome da unidade de conservação a ser buscada.",
    )
    parser.add_argument(
        "--headless",
        action="store_true",
        help="Executa a coleta do TerraBrasilis em modo headless.",
    )
    parser.add_argument(
        "--no-mark-inside",
        action="store_true",
        help="Desativa a etapa que marca pontos dentro da reserva.",
    )
    parser.add_argument(
        "--skip-geometry-output",
        action="store_true",
        help="Não salva a geometria da reserva após a execução do pipeline.",
    )
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    """Entry-point used by the command line interface."""

    from .config import configure_logging

    configure_logging()

    args = build_parser().parse_args(argv)

    reserve_kwargs: dict[str, Any] = {"name": args.reserve_name}
    if args.reserve_cache is not None:
        reserve_kwargs["cache"] = args.reserve_cache

    geometry_output: Path | None
    if args.skip_geometry_output:
        geometry_output = None
    else:
        geometry_output = args.geometry_output

    from .extract.terrabrasilis import TerraBrasilisConfig, TerraBrasilisFilters

    fetch_kwargs: dict[str, Any] = {
        "filters": TerraBrasilisFilters(),
        "config": TerraBrasilisConfig(
            headless=args.headless,
            pause_after_apply=not args.headless,
            close_browser_on_finish=True,
        ),
    }

    cfg = PipelineConfig(
        dataframe_output=args.fires_output,
        geometry_output=geometry_output,
        apply_transform=not args.no_mark_inside,
        fetch_fire_kwargs=fetch_kwargs,
        reserve_kwargs=reserve_kwargs,
    )

    run_pipeline(cfg)
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI execution helper
    raise SystemExit(main())


__all__ = [
    "PipelineConfig",
    "PipelineResult",
    "build_parser",
    "main",
    "run_pipeline",
]
